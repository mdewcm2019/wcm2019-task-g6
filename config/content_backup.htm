<h1>簡介</h1>
<p>CMSimfly (<a href="https://github.com/chiamingyen/cmsimfly">https://github.com/chiamingyen/cmsimfly)</a> 是一套簡單的網際內容管理系統, 採用 Flask 網際框架, 以 Beautifulsoup 解讀分頁內容.</p>
<p><img alt="" height="471" src="/images/gocycle4.png" width="587"/></p>
<h2>Blogger</h2>
<p>團隊部落格&gt; <a href="https://cd2019a-task1-2019cda-t1-g6.blogspot.com/">Here！</a></p>
<h1>Team Member</h1>
<p>40623153  廖祥佑</p>
<p>40623155  陳霖</p>
<p>40623156  林聖翰</p>
<p>40623157  李昀霖</p>
<h1>目錄結構</h1>
<p>CMSimfly 的動態系統採用 Python3 + Flask 建構, 並且利用 Beatifulsoup 解讀位於 contig 目錄中的 content.htm 超文件檔案.</p>
<p>content.htm 檔案可以透過動態系統中的 generate_pages 功能, 將超文件轉為位於 content 目錄中的個別頁面檔案.</p>
<p>動態系統與靜態系統則共用 downloads, images, static 等目錄, 其中 downloads 目錄存放在動態系統上傳的文件檔, 而 images 目錄則存放動態系統所上傳的影像檔案, 包括 jpg, png 與 gif 等格式圖檔.</p>
<p>static 目錄則存放在動態與靜態系統所需要的 Javascript 或 Brython 程式檔.</p>
<h1>頁面編輯</h1>
<p>CMSimfly 動態系統的網際編輯器採用 <a href="https://www.tiny.cloud/">TinyMCE4</a>, 可以放入一般超文件,  納入圖檔, 嵌入影片連結, 並且加入帶有行數的原始碼.</p>
<p>透過 File Upload 功能, 可以一次上傳多個檔案,  存入 downloads 目錄中儲存, 之後各頁面可以引入對應連結.</p>
<p>而圖檔的上傳與引用與一般檔案類似, 但上傳後存入 images 目錄中.</p>
<h2>插入程式碼</h2>
<p>CMSimfly 目前使用 Syntaxhighlighter 3.0.83:</p>
<p> <a href="http://alexgorbatchev.com/SyntaxHighlighter/">http://alexgorbatchev.com/SyntaxHighlighter/</a> </p>
<p>進行頁面中的程式碼高亮顯示.</p>
<h3>Java 程式碼</h3>
<pre class="brush:java;auto-links:false;toolbar:false" contenteditable="false">import java.util.Scanner;

public class Life {
    public static void show(boolean[][] grid){
        String s = "";
        for(boolean[] row : grid){
            for(boolean val : row)
                if(val)
                    s += "*";
                else
                    s += ".";
            s += "\n";
        }
        System.out.println(s);
    }
    
    public static boolean[][] gen(){
        boolean[][] grid = new boolean[10][10];
        for(int r = 0; r &lt; 10; r++)
            for(int c = 0; c &lt; 10; c++)
                if( Math.random() &gt; 0.7 )
                    grid[r][c] = true;
        return grid;
    }
    
    public static void main(String[] args){
        boolean[][] world = gen();
        show(world);
        System.out.println();
        world = nextGen(world);
        show(world);
        Scanner s = new Scanner(System.in);
        while(s.nextLine().length() == 0){
            System.out.println();
            world = nextGen(world);
            show(world);
            
        }
    }
    
    public static boolean[][] nextGen(boolean[][] world){
        boolean[][] newWorld 
            = new boolean[world.length][world[0].length];
        int num;
        for(int r = 0; r &lt; world.length; r++){
            for(int c = 0; c &lt; world[0].length; c++){
                num = numNeighbors(world, r, c);
                if( occupiedNext(num, world[r][c]) )
                    newWorld[r][c] = true;
            }
        }
        return newWorld;
    }
    
    public static boolean occupiedNext(int numNeighbors, boolean occupied){
        if( occupied &amp;&amp; (numNeighbors == 2 || numNeighbors == 3))
            return true;
        else if (!occupied &amp;&amp; numNeighbors == 3)
            return true;
        else
            return false;
    }

    private static int numNeighbors(boolean[][] world, int row, int col) {
        int num = world[row][col] ? -1 : 0;
        for(int r = row - 1; r &lt;= row + 1; r++)
            for(int c = col - 1; c &lt;= col + 1; c++)
                if( inbounds(world, r, c) &amp;&amp; world[r][c] )
                    num++;

        return num;
    }

    private static boolean inbounds(boolean[][] world, int r, int c) {
        return r &gt;= 0 &amp;&amp; r &lt; world.length &amp;&amp; c &gt;= 0 &amp;&amp;
        c &lt; world[0].length;
    }

}</pre>
<p></p>
<h3>Python 程式碼</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def parse_content():
    """use bs4 and re module functions to parse content.htm"""
    #from pybean import Store, SQLiteWriter
    # if no content.db, create database file with cms table
    '''
    if not os.path.isfile(config_dir+"content.db"):
        library = Store(SQLiteWriter(config_dir+"content.db", frozen=False))
        cms = library.new("cms")
        cms.follow = 0
        cms.title = "head 1"
        cms.content = "content 1"
        cms.memo = "first memo"
        library.save(cms)
        library.commit()
    '''
    # if no content.htm, generate a head 1 and content 1 file
    if not os.path.isfile(config_dir+"content.htm"):
        # create content.htm if there is no content.htm
        File = open(config_dir + "content.htm", "w", encoding="utf-8")
        File.write("&lt;h1&gt;head 1&lt;/h1&gt;content 1")
        File.close()
    subject = file_get_contents(config_dir+"content.htm")
    # deal with content without content
    if subject == "":
        # create content.htm if there is no content.htm
        File = open(config_dir + "content.htm", "w", encoding="utf-8")
        File.write("&lt;h1&gt;head 1&lt;/h1&gt;content 1")
        File.close()
        subject = "&lt;h1&gt;head 1&lt;/h1&gt;content 1"
    # initialize the return lists
    head_list = []
    level_list = []
    page_list = []
    # make the soup out of the html content
    soup = bs4.BeautifulSoup(subject, 'html.parser')
    # 嘗試解讀各種情況下的標題
    soup = _remove_h123_attrs(soup)
    # 改寫 content.htm 後重新取 subject
    with open(config_dir + "content.htm", "wb") as f:
        f.write(soup.encode("utf-8"))
    subject = file_get_contents(config_dir+"content.htm")
    # get all h1, h2, h3 tags into list
    htag= soup.find_all(['h1', 'h2', 'h3'])
    n = len(htag)
    # get the page content to split subject using each h tag
    temp_data = subject.split(str(htag[0]))
    if len(temp_data) &gt; 2:
        subject = str(htag[0]).join(temp_data[1:])
    else:
        subject = temp_data[1]
    if n &gt;1:
            # i from 1 to i-1
            for i in range(1, len(htag)):
                head_list.append(htag[i-1].text.strip())
                # use name attribute of h* tag to get h1, h2 or h3
                # the number of h1, h2 or h3 is the level of page menu
                level_list.append(htag[i-1].name[1])
                temp_data = subject.split(str(htag[i]))
                if len(temp_data) &gt; 2:
                    subject = str(htag[i]).join(temp_data[1:])
                else:
                    subject = temp_data[1]
                # cut the other page content out of htag from 1 to i-1
                cut = temp_data[0]
                # add the page content
                page_list.append(cut)
    # last i
    # add the last page title
    head_list.append(htag[n-1].text.strip())
    # add the last level
    level_list.append(htag[n-1].name[1])
    temp_data = subject.split(str(htag[n-1]))
    # the last subject
    subject = temp_data[0]
    # cut the last page content out
    cut = temp_data[0]
    # the last page content
    page_list.append(cut)
    return head_list, level_list, page_list

</pre>
<p></p>
<h3>C或C++程式碼</h3>
<p>請注意, 目前 CMSimfly 標題內文無法解讀 "/" 符號, 因此若本頁面的標題為  "C/C++程式碼", 則無法進行分頁.</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/* Runge Kutta for a set of first order differential equations */
 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
 
#define N 2 /* number of first order equations */
#define dist 0.1 /* stepsize in t*/
#define MAX 30.0 /* max for t */
 
FILE *output; /* internal filename */
FILE *output1; /* internal filename */
// 利用 pipe 呼叫 gnuplot 繪圖
FILE *pipe;
 
void runge4(double x, double y[], double step); /* Runge-Kutta function */
double f(double x, double y[], int i); /* function for derivatives */
 
void main(){
 
  double t, y[N];
  int j;
 
  output=fopen("osc.dat", "w"); /* external filename */
  output1=fopen("osc1.dat", "w"); /* external filename */
 
  y[0]=1.0; /* initial position */
  y[1]=0.0; /* initial velocity */
 
  //fprintf(output, "0\t%f\n", y[0]);
 
  for (j=1; j*dist&lt;=MAX ;j++) /* time loop */{
 
    t=j*dist;
    runge4(t, y, dist);
    fprintf(output, "%f\t%f\n", t, y[0]);
    fprintf(output1, "%f\t%f\n", t, y[1]);
  }
 
  fclose(output);
  fclose(output1);
 
  pipe = popen("gnuplot -persist","w");
  //fprintf(pipe,"set term png enhanced font \"v:/fireflysung.ttf\" 18 \n");
  fprintf(pipe,"set term png enhanced font \"y:/wqy-microhei.ttc\" 18 \n");
  //fprintf(pipe,"set yrange [68:70]\n");
  fprintf(pipe,"set output \"test.png\"\n");
  fprintf(pipe, "plot \"osc.dat\" title \"位移\" with lines, \"osc1.dat\" title \"速度\" with lines\n");
  fprintf(pipe,"quit\n");

  fprintf(pipe,"quit\n");
  pclose(pipe);
}
 
void runge4(double x, double y[], double step){
 
  double h=step/2.0, /* the midpoint */
  t1[N], t2[N], t3[N], /* temporary storage arrays */
  k1[N], k2[N], k3[N],k4[N]; /* for Runge-Kutta */
  int i;
 
  for (i=0;i&lt;N;i++){
 
    t1[i]=y[i]+0.5*(k1[i]=step*f(x,y,i));
  }
 
  for (i=0;i&lt;N;i++){
 
    t2[i]=y[i]+0.5*(k2[i]=step*f(x+h, t1, i));
  }
 
  for (i=0;i&lt;N;i++){
 
    t3[i]=y[i]+ (k3[i]=step*f(x+h, t2, i));
  }
 
  for (i=0;i&lt;N;i++){
 
    k4[i]= step*f(x+step, t3, i);
  }
 
  for (i=0;i&lt;N;i++){
 
    y[i]+=(k1[i]+2*k2[i]+2*k3[i]+k4[i])/6.0;
  }
}
 
double f(double x, double y[], int i){
 
  if (i==0)
    x=y[1]; /* derivative of first equation */
  if (i==1)
    x=-y[0]-0.5*y[1];
  return x;
}</pre>
<p></p>
<h3>Lua 程式碼</h3>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">-- 導入 js 模組
js = require("js")
-- 取得 window
window = js.global
-- 猜小於或等於 n 的整數
big = 100
-- 計算猜測次數, 配合 while 至少會猜一次
num = 1
-- 利用 window:prompt 方法回應取得使用者所猜的整數
guess = window:prompt("請猜一個介於 1 到 "..big.." 的整數")
-- 利用數學模組的 random 函數以亂數產生答案
answer = math.random(big)
output = ""
-- 若沒猜對, 一直猜到對為止
while answer ~= tonumber(guess) do
    if answer &gt; tonumber(guess) then
        output = "猜第 "..num.." 次, guess="..guess..", answer="..answer.." - too small"
        print(output)
    else
        output = "猜第 "..num.." 次, guess="..guess..", answer="..answer.." - too big"
        print(output)
    end 
    guess = window:prompt(output..", 請猜一個介於 1 到 "..big.." 的整數")
    num = num + 1
end
print("總共猜了 "..num.." 次, answer=guess="..answer.." - correct")
    </pre>
<p></p>
<h3>Javascript 程式碼</h3>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">STLViewer = function(stlpath, plotarea) {

	var mycanvas = document.getElementById(plotarea);
	var viewer = new JSC3D.Viewer(mycanvas)
	var theScene = new JSC3D.Scene;
	////Initialize with a default file:
	//var stlpath = "../../../assets/2013-10-23/stl/box.STL"
	//var stlpath = "../../../assets/2013-10-23/stl/taj.stl"
	viewer.setParameter('SceneUrl', stlpath);
    viewer.setParameter('InitRotationX', 20);
	viewer.setParameter('InitRotationY', 20);
	viewer.setParameter('InitRotationZ', 0);
	viewer.setParameter('ModelColor', '#CAA618');
	viewer.setParameter('BackgroundColor1', '#FFFFFF');
	viewer.setParameter('BackgroundColor2', '#383840');
	viewer.init();
	viewer.update();
	////init done
	var canvas_drop = document.getElementById('canvas-drop')
	/*var dropzone = document.getElementById('dropzone')
	dropzone.addEventListener('dragover', handleDragOver, false);
	dropzone.addEventListener('drop', handleFileSelect, false); */
	canvas_drop.addEventListener('dragover', handleDragOver, false);
	canvas_drop.addEventListener('drop', handleFileSelect, false);

////Drag and drop logic:
	function handleFileSelect(evt) {
	    evt.stopPropagation();
	    evt.preventDefault();
	    var files = evt.dataTransfer.files;
	    console.log(evt)
	    console.log(files)
	    preview_stl(files[0])
	  }

	  function handleDragOver(evt) {
	    evt.stopPropagation();
	    evt.preventDefault();
	    evt.dataTransfer.dropEffect = 'copy';
	  }

////jsc3d logic
	var handle_file_select = function(e) {
		e.stopPropagation()
		e.preventDefault()
		var f = e.target.files[0]
		preview_stl(f)
	}

	function preview_stl(f) {
		var reader = new FileReader()
		var ext = f.name.split(".")[1]

		function setup_viewer() {
			viewer.setParameter('InitRotationX', 20);
			viewer.setParameter('InitRotationY', 20);
			viewer.setParameter('InitRotationZ', 0);
			viewer.setParameter('ModelColor', '#CAA618');
			viewer.setParameter('BackgroundColor1', '#FFFFFF');
			viewer.setParameter('BackgroundColor2', '#383840');
			viewer.setParameter('RenderMode', "flat");
		}
		setup_viewer()

		reader.onload = (function(file) {
			return function(e) {
				theScene = new JSC3D.Scene
		    	stl_loader = new JSC3D.StlLoader()
		    	stl_loader.parseStl(theScene, e.target.result)
		      	//viewer.init()
		      	viewer.replaceScene(theScene)
		      	viewer.update()
		      	console.log("file reader onload")
			}
		})(f)

		if (ext.toLowerCase() != "stl") {
			alert("That doesn't appear to be an STL file.");
		} else {
			reader.readAsBinaryString(f)
		}
	}
}
</pre>
<p></p>
<h3>Html 原始碼</h3>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;html&gt;
   &lt;head&gt;
      &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
      &lt;title&gt;CMSimfly&lt;/title&gt;
      &lt;link rel="stylesheet" type="text/css" href="/static/cmsimply.css"&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;div class='container'&gt;
      &lt;nav&gt;
         &lt;ul id='css3menu1' class='topmenu'&gt;
            &lt;li&gt;&lt;a href='/get_page/簡介'&gt;簡介&lt;/a&gt;
            &lt;li&gt;&lt;a href='/get_page/目錄結構'&gt;目錄結構&lt;/a&gt;
            &lt;li&gt;
               &lt;a href='/get_page/頁面編輯'&gt;頁面編輯&lt;/a&gt;
               &lt;ul&gt;
                  &lt;li&gt;
                     &lt;a href='/get_page/插入程式碼'&gt;插入程式碼&lt;/a&gt;
                     &lt;ul&gt;
                        &lt;li&gt;&lt;a href='/get_page/Java 程式碼'&gt;Java 程式碼&lt;/a&gt;
                        &lt;li&gt;&lt;a href='/get_page/Python 程式碼'&gt;Python 程式碼&lt;/a&gt;
                        &lt;li&gt;&lt;a href='/get_page/C或C++程式碼'&gt;C或C++程式碼&lt;/a&gt;
                        &lt;li&gt;&lt;a href='/get_page/Lua 程式碼'&gt;Lua 程式碼&lt;/a&gt;
                        &lt;li&gt;&lt;a href='/get_page/Javascript 程式碼'&gt;Javascript 程式碼&lt;/a&gt;
                        &lt;li&gt;&lt;a href='/get_page/Html 原始碼'&gt;Html 原始碼&lt;/a&gt;&lt;/li&gt;
                        &lt;/li&gt;
                     &lt;/ul&gt;
               &lt;/ul&gt;
            &lt;li&gt;&lt;a href='/get_page/網際簡報'&gt;網際簡報&lt;/a&gt;
            &lt;li&gt;&lt;a href='/get_page/網誌編輯'&gt;網誌編輯&lt;/a&gt;
            &lt;li&gt;&lt;a href='/get_page/已知錯誤'&gt;已知錯誤&lt;/a&gt;&lt;/li&gt;
         &lt;/ul&gt;
      &lt;/nav&gt;
      &lt;section&gt;
         &lt;form method='post' action='/ssavePage'&gt;
         &lt;textarea class='simply-editor' name='page_content' cols='50' rows='15'&gt;&lt;h3&gt;Html 原始碼&lt;/h3&gt;&lt;/textarea&gt;
         &lt;input type='hidden' name='page_order' value='9'&gt;
         &lt;input type='submit' value='save'&gt;
         &lt;input type=button onClick="location.href='/get_page/Html 原始碼'" value='viewpage'&gt;
         &lt;/form&gt;
      &lt;/section&gt;
   &lt;/body&gt;
&lt;/html&gt;
COPY TO CLIPBOARD	</pre>
<p></p>
<h1>網際簡報</h1>
<p>CMSimfly 中採用 <a href="https://revealjs.com/#/">Reveal.js</a> 作為網際簡報, 其中的維護檔案位於 config/reveal.js, 而對應的簡報檔案則位於 reveal 目錄中.</p>
<h1>網誌編輯</h1>
<p>CMSimfly 彩用 <a href="https://blog.getpelican.com/">Pelican blog</a> 系統, 編輯檔案位於 config/pelican.leo, 對應的</p>
<p> Markdown 原始檔案位於 markdown 目錄中, 而經 Pelican 轉換出的網誌超文件檔案則位於 blog 目錄中.</p>
<p>其餘在網誌文章中所需要的 Javascript 或 Brython 程式檔案, 則與 CMSimfly 及 Reveal.js 共用, 位於 static 目錄下.</p>
<p>上傳檔案與圖檔的引用則與 CMSimfly 架構相同.</p>
<h1>已知錯誤</h1>
<h4>全部頁面會因無法正確解讀而誤刪</h4>
<p>在特定情況下, 系統會誤刪 config/content.htm 檔案, 目前在單頁或全部頁面編輯存檔之前, 或將上一版本的 content.htm 存入 content_back.htm, 若 content.htm 內容被程式誤刪, 可以利用備份檔案複製回原始內容後, 再進行後續處理.</p>
<h4>頁面標題不支援特殊符號</h4>
<p>各頁面標題目前不支援特殊符號, 例如: "/", "?" 等, 若已經發生程式無法解讀頁面的情況, 只能從編輯 config/content.htm 下手, 若系統位於遠端, 則後續必須要再設法提供一個額外的編輯 config/content.htm 檔案的網際連結功能.</p>
<h4>Video 引用不支援內部引用</h4>
<p>tinymce 中插入 video 的小視窗, 要移除引用的圖像與連結, 因為一般建議不要在內容中存入 .mp4 的影片資料, 而只接受引入影片 URL 連結.</p>
<h1>課程筆記</h1>
<h2>網際網路故障排除</h2>
<p>遇到學校伺服器IP掛掉問題<br/>Step1.關閉網路第四版協定</p>
<p><img alt="" height="708" src="/images/SfF6oN78hU.png" width="1244"/><img alt="" height="708" src="/images/SfF6oN78hU.png" width="1244"/></p>
<p>打開IPV6</p>
<p>修改內容設定，打開DNS並輸入</p>
<p>2001:b000:168::1</p>
<p><img alt="" height="518" src="/images/dllhost_QcMKXfshAM.png" width="630"/><img alt="" height="518" src="/images/dllhost_QcMKXfshAM.png" width="630"/></p>
<p>修改proxy內容</p>
<p>[2001:288:6004:17::4]</p>
<p><img alt="" height="386" src="/images/rundll32_9PmorqmYBC.png" width="443"/><img alt="" height="518" src="/images/dllhost_QcMKXfshAM.png" width="630"/></p>
<p>完成修改後便能成功上網。</p>
<p></p>
<p>完成修改後便能成功上網</p>
<<<<<<< HEAD
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h2>Git筆記重點整理</h2>
=======
<h2>Git筆記重點整理</h2>
<p>線上觀看手冊</p>
<p><a href="https://git-scm.com/book/zh-tw/v2">https://git-scm.com/book/zh-tw/v2</a></p>
<h3>開始</h3>
<h4>版本控制系統</h4>
<p><img alt="" height="683" src="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g6/images/p01.png" width="800"/></p>
<p>利用RCS指令可控制任一版本資料，其<span>工作原理是在硬碟上保存一堆特殊格式的補丁集合，通過套用功能，便可以重新產生出每個版本的檔案內容。</span></p>
<p><span>Git控制方法分成</span><span>集中化與分散式版本控制系統</span></p>
<p><span>集中化版本控制系統</span></p>
<p><span><img alt="" height="556" src="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g6/images/p02.png" width="800"/></span></p>
<p>好處：</p>
<p>1.清楚了解分組內各成員所做進度<br/>2.管理員統一控制所有開發者權限<br/>3.各用戶端統一使用統一版本系統，好管理<br/>壞處：<br/>1.中央伺服器發生故障，各開發者便無法協同合作<br/>2.統一集中資料會有遺失資料風險</p>
<p>分散式版本控制系統<br/><br/>因集中化控制的不便，進而衍化出分散式控制系統</p>
<p><img alt="" height="800" src="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g6/images/p03.png" width="668"/><br/>優點：<br/>1.任一協同伺服器故障，事後都能以任一用戶端鏡像還原<br/>2.能與許多遠端倉儲互動，使不同地方群組能在不一樣的地方完成同一專案協同合作<br/>3.階層式的分工合作<br/><br/></p>
<p>-------------------------------------------------------------------------------------------------------------</p>
<p><strong>Git完整性</strong></p>
<p><br/><span>1.Git 中所有的物件在儲存前都會被計算校驗碼（checksum）並以校驗碼參照物件。</span><br/>2.計算較驗碼<span>機制稱為 SHA-1 雜湊演算法。 一個校驗碼是由 40 個 16 進位的字母（0–9 和 a–f）所組成，Git 會根據檔案的內容和資料夾的結構來計算。 <br/>3. Git 的資料庫內，每個檔案都是用其內容的校驗碼來儲存，而不是使用檔名。</span></p>
<p><strong>Git狀態</strong></p>
<p>1.已提交（committed）：<br/><span>檔案己安全地存在你的本地端資料庫。</span></p>
<p>2.<span>已修改（modified）：<br/>檔案已被修改但尚未提交到本地端資料庫。 <br/></span></p>
<p>3.<span>已預存（staged）：<br/>已預存代表這檔案將會被存到下次你提交的快照中。<br/><br/></span></p>
<p><span><img alt="" height="441" src="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g6/images/p04.png" width="800"/></span></p>
<p><strong>Git工作流程</strong></p>
<p>1.你在你工作目錄修改檔案。</p>
<p>2.預存檔案，將檔案的快照新增到預存區。</p>
<p>3.做提交的動作，這會讓存在預存區的檔案快照永久地儲存在 Git 目錄中。</p>
<h3>Git booK L9</h3>
>>>>>>> a4799a3c26746917e515b1a93ab817cdc15c0ad1
<p><br/>9.1<a href="https://git-scm.com/book/zh-tw/v2/Git-and-Other-Systems-Git-as-a-Client">Git as a Client</a></p>
<p><span>git svn：</span><span>Git中所有Subversion橋接指令的基本指令都是</span><code>git svn</code><span><span>。</span><span>它需要相當多的指令，因此我們將在完成一些簡單的工作流程時展示最常見的指令。當用戶使用git svn時，需特別注意避免同時與Git遠端倉儲交互操作使用。</span></span></p>
<p><br/>10.1<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Plumbing-and-Porcelain">Plumbing and Porcelain</a></p>
<h4>Plumbing and Porcelain</h4>
<p><img alt="" height="283" src="/images/git.jpg" width="502"/></p>
<p><br/>10.2<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Git-Objects">Git Objects</a></p>
<h4>Git Objects</h4>
<h4>cat -file 從Git 取回資料</h4>
<h4>update - ref更新引用</h4>
<p><br/>10.3<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Git-References">Git References</a></p>
<h4>Git References</h4>
<h4>如何知道最後一次提交？:</h4>
<h4>執行  git branch </h4>
<h4><code class="language-console" data-lang="console">$ cat .git/HEAD</code></h4>
<h4><br/><code class="language-console" data-lang="console">ref: refs/heads/master</code><code class="language-console" data-lang="console"><br/><br/><br/><code>執行 git checkout test<br/><br/></code></code></h4>
<h4><code class="language-console" data-lang="console">$ cat .git/HEAD</code></h4>
<h4><code class="language-console" data-lang="console">ref: refs/heads/test<br/><br/>也可以手動編輯此文件，但同樣可以執行更安全的命令:<br/><span><br/>執行symbolic-ref<br/><br/></span></code></h4>
<h4><code class="language-console" data-lang="console">$ git symbolic-ref HEAD</code></h4>
<h4><code class="language-console" data-lang="console">refs/heads/master<br/><br/>設置HEAD:<br/><br/></code></h4>
<h4><br/><code class="language-console" data-lang="console">$ git symbolic-ref HEAD<span> </span></code><code class="language-console" data-lang="console">refs/heads/test</code></h4>
<h4><code class="language-console" data-lang="console">$ cat .git/HEAD</code></h4>
<h4><code class="language-console" data-lang="console">ref: refs/heads/test</code></h4>
<pre class="highlight"></pre>
<<<<<<< HEAD
<p><br/>10.4<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Packfiles">Packfiles</a> <br/>10.5<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-The-Refspec">The Refspec</a></p>
=======
<p><br/>10.4<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Packfiles">Packfiles</a></p>
<p><strong>使用 git cat-file 命令查看這個文件大小</strong></p>
<p>$ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5<br/>22044</p>
<p><br/><strong>使用git gc打包文件</strong></p>
<p><br/>$ git gc Counting objects: 18, done. Delta compression using up to 8 threads. Compressing objects: 100% (14/14), done. Writing objects: 100% (18/18), done. Total 18 (delta 3), reused 0 (delta 0)</p>
<p></p>
<p><br/>10.5<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-The-Refspec">The Refspec</a></p>
>>>>>>> a4799a3c26746917e515b1a93ab817cdc15c0ad1
<p>The Refspec</p>
<p>.git / config文件中添加遠端origin的名稱，遠程存儲庫的URL以及用於獲取的refspec</p>
<pre class="highlight"><code class="language-ini" data-lang="ini">[remote "origin"]
	url = https://github.com/schacon/simplegit-progit
	fetch = +refs/heads/<em>:refs/remotes/origin/<br/><br/></em>如果想一次性執行某些操作，也可以在命令行中指定refspec<br/></code></pre>
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin master:refs/remotes/origin/mymaster<br/><br/>指定多個refspec<br/><br/></code></pre>
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin master:refs/remotes/origin/mymaster \
	 topic:refs/remotes/origin/topic
From git@github.com:schacon/simplegit
 ! [rejected]        master     -&gt; origin/mymaster  (non fast forward)
 * [new branch]      topic      -&gt; origin/topic<br/><br/>刪除</code><code class="language-console" data-lang="console">refspec<br/>git push origin :topic<br/><br/>git push origin -- delete topic<br/></code></pre>
<p><br/>10.6<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Transfer-Protocols">Transfer Protocols</a></p>
<p>Transfer Protocols--傳輸協議</p>
<p><span>Git可以透過兩種主要方式在兩個倉儲之間傳輸數據：“啞吧”協議與“智能”協議。</span><span>本章重點著重於介紹這兩個主要協議的運作方式。</span></p>
<p><span>The Dumb Protocol--啞巴協議</span></p>
<p><span><span>該協議稱為“啞巴協議”，是因為它在傳輸過程中不需要服務端的Git特定代碼; 獲取過程是一系列HTTP </span><code>GET</code><span><span>請求，使用者可以自由的呈現Git倉儲的安排。</span></span></span></p>
<p><br/>10.7<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Transfer-Protocols">Transfer Protocols</a></p>
<p><span>本章重點在介紹Git內部的維護和數據的恢復，有時Git會自動執行一個名為“auto <g class="gr_ gr_41 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" data-gr-id="41" id="41">gc</g>”的指令，大多數情況下，此指令不執行任何操作，但如果有過多的packfiles，則Git會執行git gc的指令，此指令會刪除不必要的文件。</span></p>
<p>不小心遺失提交則可使用git long和git master兩個指令來進行恢復。</p>
<p><br/>10.8<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Environment-Variables">Environment Variables</a></p>
<p><span>Git總是在</span><code>bash</code><span>shell中運行，並使用許多shell環境變量來確定它的行為方式。</span></p>
<p><span><span><strong><code>GIT_EXEC_PATH：可透過運行檢查當前設置<code>git --exec-path</code><span><span>。</span></span></code></strong></span></span></p>
<p><span><span><strong><code><span>HOME：它是Git查找全局配置文件的地方。</span></code></strong></span></span></p>
<p><span><span><strong><code><span>GIT_CONFIG_NOSYSTEM：如果您的系統配置干擾了您的指令，但是您無權更改或刪除它，這將非常有用。</span></code></strong></span></span></p>
<p><span><span><strong><code><span>GIT_COMMITTER_NAME</span></code></strong></span></span><span><span><strong><code><span><span><span><span> 設置提交者的名字</span>。</span></span></span></code></strong></span></span></p>
<div class="paragraph">
<p><strong><code>GIT_COMMITTER_EMAIL</code></strong><span><span> </span>是“提交者”字段的電子郵件地址。</span></p>
</div>
<div class="paragraph">
<p><strong><code>GIT_COMMITTER_DATE</code></strong><span><span><span> </span>用於“提交者”字段中的日期。</span></span></p>
<br/>10.9<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Summary">Summary</a>
<p><span>Git為一個非常強大的系統工具，可以輕鬆使用它作為VCS。本章介紹了許多管道指令 - 這些指令使用戶在使用上更家簡單。</span></p>
<<<<<<< HEAD
=======
<h1>課程內容</h1>
>>>>>>> a4799a3c26746917e515b1a93ab817cdc15c0ad1
</div>
<h2>ssh.key操作步驟</h2>
<p><strong>關閉彈出的登入窗</strong></p>
<p>開啟start.bat後輸入  git config --edit --system</p>
<p>開啟編輯器，編輯git的設定</p>
<p>使用按鍵H/J/K/L控制方向，之後按a進入編輯模式</p>
<p>就可以按Backspace刪除最後一行</p>
<p>如下</p>
<p><img alt="" height="533" src="/images/ssh.png" width="1008"/></p>
<p>刪除後按Esc鍵離開編輯模式</p>
<p>輸入2個冒號後，再輸入wq存檔並關閉即可</p>
<p>直接離開則輸入exit即可退出</p>
<p>在可攜系統的程式視窗輸入sh (可至y:\git\bin中確認)</p>
<p>執行 git 的 shell並輸入(ssh-keygen -t rsa -b 4096 -C "This is my key")</p>
<p>將會建立Private 與 Public金鑰至y:\home\.ssh\id_rsa與id_rsa.pub將 id_rsa.pub 的內容複製貼上至Github 帳號的Settings</p>
<p>如下</p>
<p><img alt="" height="599" src="/images/ssh1.png" width="295"/></p>
<p><span>在SSH and GPG keys的SSH Key點擊new ssh key並貼上所複製的的內容</span></p>
<p><span><img alt="" height="502" src="/images/ssh-2.png" width="1000"/></span></p>
<p><strong>利用ssh提交推送</strong></p>
<p>首先要確認倉儲是以ssh的方式clone</p>
<p>利用以下指令clone</p>
<p>git clone git@github.com:(mdekmol/github分組網址)</p>
<p>或直接使用SciTE編輯器開啟個人倉儲的.git檔案裡面的config檔案</p>
<p>把url = https://github.com/<span>(</span><span>mdekmol/github分組網址)</span></p>
<p>改成url = git@github.com:<span>(</span><span>mdekmol/github分組網址)</span></p>
<p>完成後直接提交推送即可不用打帳號密碼就能push。</p>
<pre class="highlight"><code class="language-console" data-lang="console"><br/><br/><br/><br/><br/><br/><br/></code></pre>
<p></p>
<<<<<<< HEAD
<p>=======</p>
<h1>ungit使用方法</h1>
<p> git add . 後使用 ungit</p>
<p><img src="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g5/images/ApplicationFrameHost_1fEDHwoqFq.png"/></p>
<p><span>輸入這次提交的主題後按下commit</span></p>
<p><span><img src="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g5/images/ApplicationFrameHost_mOu4EkehpQ.png"/></span></p>
<p><span>在按一次commit後的分支點擊push</span></p>
<p><span><img alt="" height="632" src="/images/未命名.png" width="869"/></span></p>
<p>再輸入使用者帳號密碼後推送完成</p>
<p>!!輸入完成後要直接按"Submit"扭，使用鍵盤的"Enter"無法完成!!</p>
<p><img src="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g5/images/ApplicationFrameHost_b08aFeUUTX.png"/></p>
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt; d72756a82c290f232962f331f85ffee18201161c</p>
=======
<p></p>
<p></p><h1>ungit</h1>
<h2>使用方法</h2>
<p></p>
<p> git add . 後使用 ungit</p>
<p><img alt="" height="758" src="/images/1.png" width="794"/></p>
<p>輸入這次提交的主題後按下commit</p>
<p><img alt="" height="265" src="/images/2.png" width="451"/></p>
<p><span>在按一次commit後的分支點擊push</span></p>
<p><span><img alt="" height="632" src="/images/未命名.png" width="869"/></span></p>
<p>再輸入使用者帳號密碼後推送完成</p>
<p>輸入完成後直接按下Submit即可</p>
<p><img alt="" height="290" src="/images/3.png" width="596"/></p>
<p></p>
>>>>>>> a4799a3c26746917e515b1a93ab817cdc15c0ad1
